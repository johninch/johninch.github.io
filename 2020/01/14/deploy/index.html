<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="前端工程化部署deploy"><meta name="keywords" content="线上部署流程,nginx原理,cdn原理,CI/CD配置"><meta name="author" content="Johninch"><meta name="copyright" content="Johninch"><title>前端工程化部署deploy | JohninchのBlog</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.3"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"0XJEPPY0XU","apiKey":"e06877afb5799837e43083eaa72dae92","indexName":"inch-blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、前端项目工程化部署流程"><span class="toc-number">1.</span> <span class="toc-text">一、前端项目工程化部署流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、CI-CD相关知识"><span class="toc-number">2.</span> <span class="toc-text">二、CI/CD相关知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、CDN相关知识"><span class="toc-number">3.</span> <span class="toc-text">三、CDN相关知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Nginx静态资源相关知识"><span class="toc-number">4.</span> <span class="toc-text">四、Nginx静态资源相关知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-number">5.</span> <span class="toc-text">参考文章</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/16729420?s=460&amp;v=4"></div><div class="author-info__name text-center">Johninch</div><div class="author-info__description text-center">张宇驰的博客主页</div><div class="follow-button"><a href="https://github.com/johninch">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">15</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">36</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://https://johninch.github.io/Roundtable/">Roundtable-io</a><a class="author-info-links__name text-center" href="https://github.com/johninch/Roundtable">Roundtable-repo</a><a class="author-info-links__name text-center" href="https://github.com/esop-fed">ESOP-FED</a><a class="author-info-links__name text-center" href="https://dannisi.github.io/">Caleb</a><a class="author-info-links__name text-center" href="https://niannings.github.io/">niannings</a><a class="author-info-links__name text-center" href="https://Xmtd.github.io/">Xmtd</a><a class="author-info-links__name text-center" href="https://febcat.github.io/">febcat</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">JohninchのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">前端工程化部署deploy</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-13</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 10 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>本文记录了ESOP-FED 项目工程化部署方案，分别涉及 线上部署流程，nginx原理，cdn原理，CI/CD配置…</p>
</blockquote>
<a id="more"></a>

<h2 id="一、前端项目工程化部署流程"><a href="#一、前端项目工程化部署流程" class="headerlink" title="一、前端项目工程化部署流程"></a>一、前端项目工程化部署流程</h2><ol>
<li>提交代码，push 到 git 远程仓库；</li>
<li>触发 gitlab-ci 的 runners，构建.gitlab-ci.yml中配置的 job；</li>
<li>.gitlab-ci.yml中配置的job，大致会做：从仓库拉取项目代码到nginx服务器，运行 npm run build，运行 npm run cdn；</li>
<li>使用nginx作为静态服务器，代理静态服务，将前端构建好的静态资源dist文件包，都托管到指定服务目录，通过listen配置好的端口（默认80），即可访问静态服务；</li>
<li>npm run build 会把构建好的代码输出到dist目录中，放到nginx静态资源服务器的指定目录里。为了优化，将大部分的静态资源托管到第三方cdn平台上，而在nginx服务器上只托管dist下的index.html入口文件就好了；</li>
<li>npm run cdn 把静态资源（除入口文件外所有的 js，css，img，font等等）上传到 cdn。每次上传都会在项目根目录下生成静态资源清单文件（static.config.json），以输出比较本次构建与之前构建的静态资源文件列表日志；</li>
<li>通过浏览器，访问网站前端域名，网站通过index.html入口文件的script标签记录的链接，加载app.xxx.js（同步模块代码）、vendor.xxx.js（依赖包代码）、manifest.xxx.js（异步模块清单），当路由切换时动态获取异步模块；</li>
</ol>
<h2 id="二、CI-CD相关知识"><a href="#二、CI-CD相关知识" class="headerlink" title="二、CI/CD相关知识"></a>二、CI/CD相关知识</h2><p>CI/CD系统：持续集成和持续部署是微服务架构下的必要组成部分， <code>Jenkins</code>、Github 默认支持的 <code>Travis</code> 以及 <code>GitLab CI</code> 都是常用的 CI 工具。<br>CI/CD持续集成和持续部署 就是指测试和发布环节，如果能够做到自动化，那么就可以大大加快开发迭代的速度。</p>
<p><strong>GitLab CI 相关术语：</strong></p>
<ul>
<li><p>Pipeline：流水线。一次 Pipeline 其实相当于一次构建任务。任何提交或者 MR 的合并都可以触发 Pipeline；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+           +----------------+</span><br><span class="line">|                  |  trigger  |                |</span><br><span class="line">|   Commit / MR    +----------&gt;+    Pipeline    |</span><br><span class="line">|                  |           |                |</span><br><span class="line">+------------------+           +----------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>Stage：构建阶段。一次 Pipeline 中可以定义多个 Stages，所有 Stages 会按照顺序运行，只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功，任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------------------------------------------------+</span><br><span class="line">|  Pipeline                                              |</span><br><span class="line">|                                                        |</span><br><span class="line">|  +-----------+     +------------+      +------------+  |</span><br><span class="line">|  |  Stage 1  |----&gt;|   Stage 2  |-----&gt;|   Stage 3  |  |</span><br><span class="line">|  +-----------+     +------------+      +------------+  |</span><br><span class="line">|                                                        |</span><br><span class="line">+--------------------------------------------------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>Jobs，构建工作。是最小的任务单元，每个job只负责一件事情，要么编译，要么测试等。可以在 Stages 里面定义多个 Jobs，一个Stage中的 Jobs 会并行执行，一个Stage中的 Jobs 都执行成功时，该 Stage 才会成功，任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------------------------------+</span><br><span class="line">|  Stage 1                                 |</span><br><span class="line">|                                          |</span><br><span class="line">|  +---------+  +---------+  +---------+   |</span><br><span class="line">|  |  Job 1  |  |  Job 2  |  |  Job 3  |   |</span><br><span class="line">|  +---------+  +---------+  +---------+   |</span><br><span class="line">|                                          |</span><br><span class="line">+------------------------------------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>GitLab Runner，是实际处理 Job 的，每个 Runner 可以单独配置，Runner 支持多种类型的 Job，同一时间单个 runner 只能处理一个 Job；</p>
</li>
<li><p>GitLab Multi Runner，是一个 GitLab 的开源项目，用来统一管理 Runner；</p>
</li>
<li><p>Executor，每个 Runner 都需要指定一个 Executor，来决定 runner 最终使用哪个执行器进行处理。</p>
</li>
</ul>
<p><strong>CI/CD流程：</strong><br>一个典型的 Pipeline，一共有 5 个阶段，Build，Test，Release， Staging， Production，每个阶段里都至少有一个 Job，Test 中有两个 Job。GitLab 会从左往右依次把任务给到 Runner 处理，如果中途有一个任务没有处理成功的话，整个 Pipeline 就会退出。这就是持续集成（CI）、持续发布（CD） 的一个流程。</p>
<p><strong>如何使用 GitLab CI：</strong></p>
<ul>
<li><p>Gitlab-CI 是GitLab Continuous Integration（Gitlab持续集成）的简称。从Gitlab的8.0版本开始，gitlab就全面集成了Gitlab-CI,并且对所有项目默认开启。只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次合并请求（MR）或者push都会触发CI pipeline。</p>
</li>
<li><p>GitLab 中提供了两种 Runner 的类型，特定的 Specific Runner（只能供部分项目使用），共享的 Shared Runner（所有 GitLab 中的项目都可以使用）；</p>
</li>
<li><p>比如注册一个 Specific Runner：</p>
<ul>
<li><p>第一步安装 GitLab Mutli Runner，直接采用二进制安装即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># For Debian/Ubuntu</span><br><span class="line">sudo apt-get install gitlab-ci-multi-runner</span><br><span class="line"></span><br><span class="line"># For CentOS</span><br><span class="line">sudo yum install gitlab-ci-multi-runner</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步注册Runner，<code>输入 Gitlab 地址、项目token、runner名称、runner描述、选择执行器类型（shell, docker, docker-ssh, ssh...）等</code>。注册好了，由于 Multi Runner 支持动态加载配置，所以 Runner 就立即生效了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$sudo gitlab-ci-multi-runner register</span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/ci )</span><br><span class="line">http://gitlab.###.io/ci</span><br><span class="line">Please enter the gitlab-ci token for this runner</span><br><span class="line">########################</span><br><span class="line">Please enter the gitlab-ci description for this runner</span><br><span class="line">my-runner</span><br><span class="line">INFO[0034] fcf5c619 Registering runner... succeeded</span><br><span class="line">Please enter the executor: shell, docker, docker-ssh, ssh?</span><br><span class="line">shell</span><br><span class="line">INFO[0037] Runner registered successfully. Feel free to start it, but if it&apos;s</span><br><span class="line">running already the config should be automatically reloaded!</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，在项目根目录中添加 .gitlab-ci.yml 文件（此文件就是定义了Pipeline的执行方式），具体配置<a href="https://docs.gitlab.com/ee/ci/yaml/README.html" target="_blank" rel="noopener">gitlab-ci.yml</a>。gitlab-ci.yml文件配置的script，使用基本的shell脚本命令，<a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">linux Shell教程</a>。gitlab-ci.yml文件中的变量，如 $CI_PROJECT_ID，$CI_COMMIT_SHA，$CI_COMMIT_REF_NAME 等变量为 GitLab CI 变量，可以在 CI 流程中直接使用这些变量，具体参考 <a href="https://docs.gitlab.com/ce/ci/variables/" target="_blank" rel="noopener">GitLab CI Variables</a>。</p>
</li>
</ul>
</li>
</ul>
<p><strong>为什么不是 GitLab CI 来运行那些构建任务？</strong></p>
<ul>
<li>构建任务都会占用很多的系统资源 (譬如编译代码)，而 GitLab CI 又是 GitLab 的一部分，如果由 GitLab CI 来运行构建任务的话，在执行构建任务的时候，GitLab 的性能会大幅下降。</li>
<li>GitLab CI 最大的作用是<code>管理各个项目的构建状态</code>，因此，运行构建任务这种浪费资源的事情就交给 GitLab Runner 去做。Gitlab-runner 是.gitlab-ci.yml脚本的运行器，Gitlab-runner是基于Gitlab-CI的API进行构建的<code>相互隔离的机器（或虚拟机）</code>。</li>
<li>GitLab Runner 不需要和Gitlab安装在同一台机器上，考虑到GitLab Runner的资源消耗问题和安全问题，GitLab Runner应该安装到不同的机器上。</li>
</ul>
<p><strong>具体到我们的项目：</strong></p>
<ul>
<li>我们的项目选用的runner执行器是 shell，比较简单，如果选择 docker的话，需要额外指定镜像。</li>
<li>目前我们主要共享172.30.xx.xx这台广州机房的测试机，其上面部署了tag为”fed-shell-ci-cd”的runnner。</li>
<li>目前位于GZ_GZJF_xxxx上的测试服务（fed-shell-ci-cd）和gz_gzjf_xxxx 的线上发布服务（ci-fed-publish）的runner均已注册为Shared Runner，默认对所有项目启用生效。所以不再需要特地关联启用Specific Runner。</li>
</ul>
<h2 id="三、CDN相关知识"><a href="#三、CDN相关知识" class="headerlink" title="三、CDN相关知识"></a>三、CDN相关知识</h2><p><strong>什么是 CDN？</strong><br>CDN（Content Delivery Network）即内容分发网络。其目的是通过在现有的 Internet 中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。可以简单理解成：<code>CDN 就是一个能让用户以最快速度访问到相应资源的网盘。</code></p>
<p><strong>使用CDN平台</strong></p>
<ul>
<li>SPA框架常用webpack来进行打包，最无脑的操作是 将打包后的dist文件整体扔到服务器上，但是用户在访问网站时，从哪个服务器拉取资源非常慢，且还要考做后端缓存。</li>
<li>更科学的方式是将dist打包文件做“动静分离”：借助CDN加速，并且云平台的CDN还自带前端缓存，非常方便。很多平台都有云服务提供，如腾讯云、阿里云…在云平台的控制台开启“对象存储”服务后，开启对应的“加速域名”，此时，针对这个存储桶，就开启了 CDN 加速。“加速域名”就是 CDN 域名。执行npm run build后，打包后的项目文件都放在了/dist/文件下。可以配置webpack，将/dist/static/文件夹直接上传到云平台的对应存储桶的根目录下即可。</li>
<li>具体上传cdn的方式，可以查看项目中的cdn.js文件。通过nodejs的rsync工具，同步文件到CDN上，每次上传都会在项目根目录下生成静态资源清单文件（static.config.json），以输出比较本次构建与之前构建的静态资源文件列表日志。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack打包输出的</span><br><span class="line">output: &#123;</span><br><span class="line">    path: outputPath, // dist目录</span><br><span class="line">    publicPath: publicPath // 浏览器引用的资源文件公共path路径，即 CDN加速路径</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="四、Nginx静态资源相关知识"><a href="#四、Nginx静态资源相关知识" class="headerlink" title="四、Nginx静态资源相关知识"></a>四、Nginx静态资源相关知识</h2><p>在前后端分离端项目里，前端的代码会被打包成为纯静态文件。使用 Nginx的目的就是<code>让静态文件运行起服务</code>，由于后端的接口也是分离的，直接请求可能会产生跨域问题，此时就需要Nginx转发代理后端接口。</p>
<ul>
<li>将前端代码打包后的dist文件放入指定服务目录</li>
<li>将服务目录指定到spa-project/dist目录下即可代理静态服务</li>
<li>配置里开启了gzip压缩，可以很大程度上减小文件体积大小</li>
<li>将404错误页面重定向到index.html，可以解决前端history路由模式由于刷新页面访问不到服务出现404的问题</li>
<li>location为代理接口，可以转发代理后端的请求接口域名或者ip，即可解决接口跨域问题<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 示例</span><br><span class="line"># For more information on configuration, see:</span><br><span class="line">#   * Official English Documentation: http://nginx.org/en/docs/</span><br><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto; #启动进程</span><br><span class="line">error_log /var/log/nginx/error.log; #全局错误日志</span><br><span class="line">pid /run/nginx.pid; #PID文件</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024; #单个后台worker process进程的最大并发链接数 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    gzip on; #开启gzip压缩</span><br><span class="line">    gzip_min_length 1k; #设置对数据启用压缩的最少字节数</span><br><span class="line">    gzip_buffers    4 16k;</span><br><span class="line">    gzip_http_version 1.0;</span><br><span class="line">    gzip_comp_level 6; #设置数据的压缩等级,等级为1-9，压缩比从小到大</span><br><span class="line">    gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; #设置需要压缩的数据格式</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    #虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  mark.binlive.cn;</span><br><span class="line">        root /home/spa-project/dist; #定义服务器的默认网站根目录位置</span><br><span class="line">        index index.html; #定义index页面</span><br><span class="line">        error_page    404         /index.html; #将404错误页面重定向到index.html可以解决history模式访问不到页面问题</span><br><span class="line">        location ^~ /api/&#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:7000;</span><br><span class="line">            proxy_send_timeout 1800;</span><br><span class="line">            proxy_read_timeout 1800;</span><br><span class="line">            proxy_connect_timeout 1800;</span><br><span class="line">            client_max_body_size 2048m;</span><br><span class="line">            proxy_http_version 1.1;  </span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;  </span><br><span class="line">            proxy_set_header Connection &quot;Upgrade&quot;; </span><br><span class="line">            proxy_set_header  Host              $http_host;   # required for docker client&apos;s sake</span><br><span class="line">            proxy_set_header  X-Real-IP         $remote_addr; # pass on real client&apos;s IP</span><br><span class="line">            proxy_set_header  X-Forwarded-For   $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header  X-Forwarded-Proto $scheme;</span><br><span class="line">        &#125;</span><br><span class="line">        location ^~ /auth/&#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:7000;</span><br><span class="line">            proxy_send_timeout 1800;</span><br><span class="line">            proxy_read_timeout 1800;</span><br><span class="line">            proxy_connect_timeout 1800;</span><br><span class="line">            client_max_body_size 2048m;</span><br><span class="line">            proxy_http_version 1.1;  </span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;  </span><br><span class="line">            proxy_set_header Connection &quot;Upgrade&quot;; </span><br><span class="line">            proxy_set_header  Host              $http_host;   # required for docker client&apos;s sake</span><br><span class="line">            proxy_set_header  X-Real-IP         $remote_addr; # pass on real client&apos;s IP</span><br><span class="line">            proxy_set_header  X-Forwarded-For   $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header  X-Forwarded-Proto $scheme;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -h // 查看Nginx的帮助</span><br><span class="line">nginx -v // 查看Nginx的版本</span><br><span class="line">nginx -t // 测试Nginx的配置</span><br><span class="line">nginx -T // 测试Nginx的配置，并打印配置信息</span><br><span class="line">nginx // 启动nginx</span><br><span class="line">nginx -s reload // 重新加载配置文件，平滑启动nginx</span><br><span class="line">nginx -s stop // 停止nginx的命令</span><br><span class="line">ps -ef |grep nginx // 查看nginx进程</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000007180257" target="_blank" rel="noopener">GitLab-CI 从安装到差点放弃</a></p>
<p><a href="https://segmentfault.com/a/1190000006120164" target="_blank" rel="noopener">用 GitLab CI 进行持续集成</a></p>
<p><a href="https://xiaozhuanlan.com/topic/3529176084" target="_blank" rel="noopener">当谈到 GitLab CI 的时候，我们该聊些什么（上篇）</a></p>
<p><a href="https://www.cnblogs.com/geyouneihan/p/9741021.html" target="_blank" rel="noopener">CDN使用心得：加速双刃剑</a></p>
<p><a href="https://juejin.im/post/5d0c4021f265da1ba431f4d4" target="_blank" rel="noopener">Node.js 实现静态文件增量上传CDN</a></p>
<p><a href="https://juejin.im/post/5b04d775f265da0b807117b1" target="_blank" rel="noopener">Nginx部署前后端分离服务以及配置说明</a></p>
<p><a href="https://segmentfault.com/a/1190000017940311?utm_source=tag-newest" target="_blank" rel="noopener">手把手搭建nginx服务器，部署前端代码</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Johninch</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://johninch.github.io/2020/01/14/deploy/">https://johninch.github.io/2020/01/14/deploy/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://johninch.github.io">JohninchのBlog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/线上部署流程/">线上部署流程</a><a class="post-meta__tags" href="/tags/nginx原理/">nginx原理</a><a class="post-meta__tags" href="/tags/cdn原理/">cdn原理</a><a class="post-meta__tags" href="/tags/CI-CD配置/">CI/CD配置</a></div><div class="social-share" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/2020/01/10/webAssembly/"><span>初探 webAssembly</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '96a2af06b5748b4ede1e',
  clientSecret: '4e684cb9e506bdd7f5732db53d3f99da0315afbb',
  repo: 'johninch.github.io',
  owner: 'johninch',
  admin: 'johninch',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Johninch</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.3"></script><script src="/js/fancybox.js?version=1.6.3"></script><script src="/js/sidebar.js?version=1.6.3"></script><script src="/js/copy.js?version=1.6.3"></script><script src="/js/fireworks.js?version=1.6.3"></script><script src="/js/transition.js?version=1.6.3"></script><script src="/js/scroll.js?version=1.6.3"></script><script src="/js/head.js?version=1.6.3"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.7,"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body></html>