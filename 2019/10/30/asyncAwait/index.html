<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="async/await 用法整理"><meta name="keywords" content="ES6,异步"><meta name="author" content="Johninch"><meta name="copyright" content="Johninch"><title>async/await 用法整理 | JohninchのBlog</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.3"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"0XJEPPY0XU","apiKey":"e06877afb5799837e43083eaa72dae92","indexName":"inch-blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#async-await-用法整理"><span class="toc-number">1.</span> <span class="toc-text">async/await 用法整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、async-await-概念解释"><span class="toc-number">1.1.</span> <span class="toc-text">1、async/await 概念解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、async-await-与-promise-相比的优势"><span class="toc-number">1.2.</span> <span class="toc-text">2、async/await 与 promise 相比的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、async关键字"><span class="toc-number">1.3.</span> <span class="toc-text">3、async关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、使用方式实践"><span class="toc-number">1.4.</span> <span class="toc-text">5、使用方式实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#（1）像写同步代码那样，定义异步流程"><span class="toc-number">1.4.1.</span> <span class="toc-text">（1）像写同步代码那样，定义异步流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（2）顺序执行，结果作为下一次输入"><span class="toc-number">1.4.2.</span> <span class="toc-text">（2）顺序执行，结果作为下一次输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（3）中间参数需要保留"><span class="toc-number">1.4.3.</span> <span class="toc-text">（3）中间参数需要保留</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、关于协程"><span class="toc-number">1.5.</span> <span class="toc-text">6、关于协程</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/16729420?s=460&amp;v=4"></div><div class="author-info__name text-center">Johninch</div><div class="author-info__description text-center">张宇驰的博客主页</div><div class="follow-button"><a href="https://github.com/johninch">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">15</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">36</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://https://johninch.github.io/Roundtable/">Roundtable-io</a><a class="author-info-links__name text-center" href="https://github.com/johninch/Roundtable">Roundtable-repo</a><a class="author-info-links__name text-center" href="https://github.com/esop-fed">ESOP-FED</a><a class="author-info-links__name text-center" href="https://dannisi.github.io/">Caleb</a><a class="author-info-links__name text-center" href="https://niannings.github.io/">niannings</a><a class="author-info-links__name text-center" href="https://Xmtd.github.io/">Xmtd</a><a class="author-info-links__name text-center" href="https://febcat.github.io/">febcat</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">JohninchのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">async/await 用法整理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/javascript/">javascript</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 15 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="async-await-用法整理"><a href="#async-await-用法整理" class="headerlink" title="async/await 用法整理"></a>async/await 用法整理</h1><p>它最受欢迎的地方：<strong>能让异步代码写起来像同步代码，并且方便控制顺序。</strong></p>
<h2 id="1、async-await-概念解释"><a href="#1、async-await-概念解释" class="headerlink" title="1、async/await 概念解释"></a>1、async/await 概念解释</h2><ul>
<li><p>async</p>
<blockquote>
<p>async的用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行，async 函数返回的是一个promise 对象。</p>
</blockquote>
</li>
<li><p>await</p>
<blockquote>
<p>await的含义为等待。意思就是代码需要等待await后面的函数运行完并且有了返回结果之后，才继续执行下面的代码。这正是同步的效果。</p>
</blockquote>
</li>
</ul>
<h2 id="2、async-await-与-promise-相比的优势"><a href="#2、async-await-与-promise-相比的优势" class="headerlink" title="2、async/await 与 promise 相比的优势"></a>2、async/await 与 promise 相比的优势</h2><ol>
<li><p><strong>同步代码编写方式</strong>:</p>
<ul>
<li>用同步的思维来解决异步问题的方案。</li>
<li>Promise使用then函数进行链式调用，一直点点点，是一种从左向右的横向写法；</li>
<li>async/await从上到下，顺序执行，就像写同步代码一样，更符合代码编写习惯。</li>
</ul>
</li>
<li><p><strong>多个参数传递</strong>:</p>
<ul>
<li>Promise的then函数只能传递一个参数，虽然可以通过包装成对象来传递多个参数，但是会导致传递冗余信息，比较麻烦；</li>
<li>async/await没有这个限制，可以当做普通的局部变量来处理，用let或者const定义的块级变量想怎么用就怎么用，完全没有限制；</li>
</ul>
</li>
<li><p><strong>同步代码和异步代码可以一起编写</strong>:</p>
<ul>
<li>使用Promise的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰；</li>
<li>async/await整个书写习惯都是同步的，不需要纠结同步和异步的区别，当然，异步过程需要包装成一个Promise对象放在await关键字后面；</li>
</ul>
</li>
<li><p><strong>基于协程</strong>:</p>
<ul>
<li>Promise是根据函数式编程的范式，对异步过程进行了一层封装；</li>
<li>async/await基于协程的机制，是真正的“保存上下文，控制权切换……控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述；</li>
</ul>
</li>
<li><p><strong>基于协程</strong>:</p>
<ul>
<li>Promise是根据函数式编程的范式，对异步过程进行了一层封装；</li>
<li>async/await基于协程的机制，是真正的“保存上下文，控制权切换……控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述；</li>
</ul>
</li>
<li><p>✨<strong>这点并不是优势也不算劣势（只能串行）</strong>:<br> 它不能取代 Promise，尤其是我们可以很方便地用Promise.all()来实现并发，而async/await只能实现串行。</p>
</li>
</ol>
<h2 id="3、async关键字"><a href="#3、async关键字" class="headerlink" title="3、async关键字"></a>3、async关键字</h2><blockquote>
<p>async函数执行和普通函数一样，函数名带个()就可以了，参数个数随意，没有限制，也需要有async关键字；只是返回值是一个Promise对象，可以用then函数得到返回值，用catch抓整个流程中发生的错误；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello async"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = testAsync(); <span class="comment">// 返回一个Promise对象</span></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// async函数返回的是一个Promise对象，async函数（包括函数语句、函数表达式、Lambda表</span></span><br><span class="line"><span class="comment">// 达式）会返回一个Promise对象，如果在函数中return一个直接量，async会把这个直接量通</span></span><br><span class="line"><span class="comment">// 过Promise.resolve() 封装成 Promise 对象；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数返回的是一个Promise对象，所以在最外层不能用await获取其返回值的情况，</span></span><br><span class="line"><span class="comment">// 应该使用原始的方式：then()链来处理这个Promise对象</span></span><br><span class="line">testAsync().then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);    <span class="comment">// 输出 hello async</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>表明程序里面可能有异步过程：</strong></p>
<ul>
<li>async关键字表明程序里面可能有异步过程，里面可以有await关键字；</li>
<li>当然全部是同步代码也没关系，但是这样async关键字就显得多余了；</li>
</ul>
</li>
<li><p><strong>非阻塞，无等待：</strong></p>
<ul>
<li>async函数里面如果有异步过程会等待，但是<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    - 可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染，async函数内部由await关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回；</span><br><span class="line">    - 在没有await的情况下执行async函数，它会立即执行，返回一个Promise对象，并且绝对不会阻塞后面的语句，这和普通返回Promise对象的函数并无二致；</span><br><span class="line"></span><br><span class="line">3. **async函数返回类型为Promise对象：**</span><br><span class="line">    这是和普通函数本质上不同的地方，也是使用时重点注意的地方；</span><br><span class="line">    - （1）return newPromise()；这个符合async函数本意；</span><br><span class="line">    - （2）return data；这个是同步函数的写法，这里是要特别注意的，这个时候，其实就相当于Promise.resolve(data)；还是一个Promise对象，但是在调用async函数的地方通过简单的=是拿不到这个data的，因为返回值是一个Promise对象，所以需要用.then(data =&gt; &#123; &#125;)函数才可以拿到这个data；</span><br><span class="line">    - （3）如果没有返回值，相当于返回了Promise.resolve(undefined)；</span><br><span class="line"></span><br><span class="line">4. **async统一catch，await不处理异步error：**</span><br><span class="line">    async函数返回的这个Promise对象的catch函数负责统一抓取内部所有异步过程的错误，await是不管异步过程的reject(error)消息的；</span><br><span class="line"></span><br><span class="line">## 4、await关键字</span><br><span class="line"></span><br><span class="line">1. **await只能在async函数内部使用：**</span><br><span class="line">    不能放在普通函数里面，否则会报错；</span><br><span class="line"></span><br><span class="line">2. **await后面也可以跟同步代码：**</span><br><span class="line">    不过系统会自动将其转化成一个Promsie对象，比如：</span><br><span class="line">    ```js</span><br><span class="line">    const a = await &apos;hello world&apos;</span><br><span class="line"></span><br><span class="line">    // 相当于</span><br><span class="line">    const a = await Promise.resolve(&apos;hello world&apos;);</span><br><span class="line"></span><br><span class="line">    // 跟同步代码是一样的，还不如省事点，直接去掉await关键字</span><br><span class="line">    const a = &apos;hello world&apos;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>✨<strong>await对于失败消息的处理：</strong><br> await只关心异步过程成功的消息resolve(data)，拿到相应的数据data，至于失败消息reject(error)，不关心不处理；对于错误的处理有以下几种方法供选择：</p>
<ol>
<li>让await后面的Promise对象自己catch；</li>
<li>也可以让外面的async函数返回的Promise对象统一catch；</li>
<li>像同步代码一样，放在一个try…catch结构中；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是React Native的回调函数，加个async关键字，没有任何影响，但是可以用await关键字</span></span><br><span class="line"><span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 将异步和同步的代码放在一个try..catch中，异常都能抓到</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> array = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">await</span> asyncFunction();  <span class="comment">// 这里用await关键字，就能拿到结果值；否则，没有await的话，只能拿到Promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (array.length &gt; <span class="number">0</span>) &#123;  <span class="comment">// 这里会抛出异常，下面的catch也能抓到</span></span><br><span class="line">            array.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        alert(<span class="built_in">JSON</span>.stringify(error))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="5、使用方式实践"><a href="#5、使用方式实践" class="headerlink" title="5、使用方式实践"></a>5、使用方式实践</h2><h3 id="（1）像写同步代码那样，定义异步流程"><a href="#（1）像写同步代码那样，定义异步流程" class="headerlink" title="（1）像写同步代码那样，定义异步流程"></a>（1）像写同步代码那样，定义异步流程</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步过程封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'sleep for '</span> + ms + <span class="string">' ms'</span>);</span><br><span class="line">        &#125;, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义异步流程，就像写同步代码那样</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'asyncFunction total executing:'</span>);</span><br><span class="line">    <span class="keyword">const</span> sleep1 = <span class="keyword">await</span> sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep1: '</span> + sleep1);</span><br><span class="line">    <span class="keyword">const</span> [sleep2, sleep3, sleep4]= <span class="keyword">await</span> <span class="built_in">Promise</span>.all([sleep(<span class="number">2000</span>), sleep(<span class="number">1000</span>), sleep(<span class="number">1500</span>)]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep2: '</span> + sleep2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep3: '</span> + sleep3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep4: '</span> + sleep4);</span><br><span class="line">    <span class="keyword">const</span> sleepRace = <span class="keyword">await</span> <span class="built_in">Promise</span>.race([sleep(<span class="number">3000</span>), sleep(<span class="number">1000</span>), sleep(<span class="number">1000</span>)]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep race: '</span> + sleepRace);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'asyncFunction total executing:'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'asyncFunction done.'</span>  <span class="comment">// 这个可以不返回，这里只是做个标记，为了显示流程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像普通函数调用async函数，在then函数中获取整个流程的返回信息，</span></span><br><span class="line"><span class="comment">// 在catch函数统一处理出错信息</span></span><br><span class="line">asyncFunction().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// asyncFunction return 的内容在这里获取: 'asyncFunction done.'</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// asyncFunction 的错误统一在这里抓取</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个代表asyncFunction函数后的代码，</span></span><br><span class="line"><span class="comment">// 显示asyncFunction本身会立即返回，不会阻塞主线程</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after asyncFunction code executing....'</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">after asyncFunction code executing....</span><br><span class="line">sleep1: sleep <span class="keyword">for</span> <span class="number">2000</span> ms</span><br><span class="line">sleep2: sleep <span class="keyword">for</span> <span class="number">2000</span> ms</span><br><span class="line">sleep3: sleep <span class="keyword">for</span> <span class="number">1000</span> ms</span><br><span class="line">sleep4: sleep <span class="keyword">for</span> <span class="number">1500</span> ms</span><br><span class="line">sleep race: sleep <span class="keyword">for</span> <span class="number">1000</span> ms</span><br><span class="line">asyncFunction total executing:: <span class="number">5006.276123046875</span>ms</span><br><span class="line">asyncFunction done.</span><br><span class="line"></span><br><span class="line"><span class="comment">// console输出：</span></span><br><span class="line"><span class="built_in">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line">    __proto__: <span class="built_in">Promise</span></span><br><span class="line">    [[PromiseStatus]]: <span class="string">"resolved"</span></span><br><span class="line">    [[PromiseValue]]: <span class="string">"asyncFunction done."</span></span><br><span class="line">VM12229:<span class="number">5</span> sleep1: sleep <span class="keyword">for</span> <span class="number">2000</span> ms</span><br><span class="line">VM12229:<span class="number">7</span> sleep2: sleep <span class="keyword">for</span> <span class="number">2000</span> ms</span><br><span class="line">VM12229:<span class="number">8</span> sleep3: sleep <span class="keyword">for</span> <span class="number">1000</span> ms</span><br><span class="line">VM12229:<span class="number">9</span> sleep4: sleep <span class="keyword">for</span> <span class="number">1500</span> ms</span><br><span class="line">VM12229:<span class="number">11</span> sleep race: sleep <span class="keyword">for</span> <span class="number">1000</span> ms</span><br><span class="line">VM12229:<span class="number">12</span> asyncFunction total executing:: <span class="number">5004.796875</span>ms</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>after asyncFunction code executing….代码位置在async函数asyncFunction()调用之后，反而先输出，这说明async函数asyncFunction()调用之后会马上返回，不会阻塞主线程；</li>
<li>sleep1: sleep for 2000 ms这是第一个await之后的第一个异步过程，最先执行，也最先完成，说明后面的代码，不论是同步和异步，都在等他执行完毕；</li>
<li>sleep2 ~ sleep4这是第二个await之后的Promise.all()异步过程，这是“比慢模式”，三个sleep都完成后，再运行下面的代码，耗时最长的是2000ms；</li>
<li>sleep race: sleep for 1000 ms这是第三个await之后的Promise.race()异步过程，这是“比快模式”，耗时最短sleep都完成后，就运行下面的代码，耗时最短的是1000ms；</li>
<li>asyncFunction total executing:: 5006.276123046875ms这是最后的统计总共运行时间代码，三个await之后的异步过程之和：<blockquote>
<p>1000（独立的） + 2000（Promise.all） + 1000（Promise.race） = 5000ms</p>
</blockquote>
</li>
<li>这个和统计出来的5006.276123046875ms非常接近，说明上面的异步过程，和同步代码执行过程一致，协程真的是在等待异步过程执行完毕；</li>
<li>asyncFunction done.这个是async函数返回的信息，在执行时的then函数中获得，说明整个流程完毕之后参数传递的过程；</li>
</ul>
<h3 id="（2）顺序执行，结果作为下一次输入"><a href="#（2）顺序执行，结果作为下一次输入" class="headerlink" title="（2）顺序执行，结果作为下一次输入"></a>（2）顺序执行，结果作为下一次输入</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span></span><br><span class="line"><span class="comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise方式调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))</span><br><span class="line">        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br><span class="line"></span><br><span class="line"><span class="comment">// c:\var\test&gt;node --harmony_async_await .</span></span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 500</span></span><br><span class="line"><span class="comment">// step3 with 700</span></span><br><span class="line"><span class="comment">// result is 900</span></span><br><span class="line"><span class="comment">// doIt: 1507.251ms</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async/await方式调用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure>

<h3 id="（3）中间参数需要保留"><a href="#（3）中间参数需要保留" class="headerlink" title="（3）中间参数需要保留"></a>（3）中间参数需要保留</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span></span><br><span class="line"><span class="comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(m + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">k, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;k&#125;</span>, <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(k + m + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise方式调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> step2(time1, time2)</span><br><span class="line">                .then(<span class="function"><span class="params">time3</span> =&gt;</span> [time1, time2, time3]);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">times</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> [time1, time2, time3] = times;</span><br><span class="line">            <span class="keyword">return</span> step3(time1, time2, time3);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br><span class="line"></span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 300 and 500</span></span><br><span class="line"><span class="comment">// step3 with 300, 500 and 1000</span></span><br><span class="line"><span class="comment">// result is 2000</span></span><br><span class="line"><span class="comment">// doIt: 2913.488037109375ms</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这里为什么不能直接这样写promise式调用，因为中间参数 time2、time3都没有办法保存</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time1, time2))</span><br><span class="line">        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time1, time2, time3))</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async/await方式调用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time1, time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time1, time2, time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br><span class="line"></span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 300 and 500</span></span><br><span class="line"><span class="comment">// step3 with 300, 500 and 1000</span></span><br><span class="line"><span class="comment">// result is 2000</span></span><br><span class="line"><span class="comment">// doIt: 2913.488037109375ms</span></span><br></pre></td></tr></table></figure>

<h2 id="6、关于协程"><a href="#6、关于协程" class="headerlink" title="6、关于协程"></a>6、关于协程</h2><details>
<summary>关于协程</summary>

<ul>
<li><p>进程&gt;线程&gt;协程</p>
</li>
<li><p>协程的第一大优势是具有极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p>
</li>
<li><p>协程的第二大优势是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多；</p>
</li>
<li><p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行，需要注意的是：在一个子程序中中断，去执行其他子程序，这并不是函数调用，有点类似于CPU的中断；</p>
<blockquote>
<p>用汽车和公路举个例子：js公路只是单行道（主线程），但是有很多车道（辅助线程）都可以汇入车流（异步任务完成后回调进入主线程的任务队列）；generator把js公路变成了多车道（协程实现），但是同一时间只有一个车道上的车能开（依然单线程），不过可以自由变道（移交控制权）；</p>
</blockquote>
</li>
<li><p>协程意思是多个线程互相协作，完成异步任务，运行流程大致如下：<br>  1）协程A开始执行；<br>  2）协程A执行到一半，进入暂停，执行权转移到协程B；<br>  3）一段时间后，协程B交还执行权；<br>  4）协程A恢复执行；</p>
</li>
<li><p>协程是一个无优先级的子程序调度组件，允许子程序在特定的地点挂起恢复；</p>
</li>
<li><p>线程包含于进程，协程包含于线程，只要内存足够，一个线程中可以有任意多个协程，但某一个时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源；</p>
</li>
<li><p>就实际使用理解来说，协程允许我们写同步代码的逻辑，却做着异步的事，避免了回调嵌套，使得代码逻辑清晰；</p>
</li>
<li><p>何时挂起，唤醒协程：协程是为了使用异步的优势，异步操作是为了避免IO操作阻塞线程，那么协程挂起的时刻应该是当前协程发起异步操作的时候，而唤醒应该在其他协程退出，并且他的异步操作完成时；</p>
</li>
<li><p>单线程内开启协程，一旦遇到io，从应用程序级别（而非操作系统）控制切换对比操作系统控制线程的切换，用户在单线程内控制协程的切换，优点如下：<br>1）协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级；<br>2）单线程内就可以实现并发的效果，最大限度地利用cpu；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">def consumer():</span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> not n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">'[CONSUMER] Consuming %s...'</span> % n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"></span><br><span class="line">def produce(c):</span><br><span class="line">    c.next()</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[PRODUCER] Producing %s...'</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(<span class="string">'[PRODUCER] Consumer return: %s'</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[PRODUCER] Producing <span class="number">1.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">1.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">2.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">2.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">3.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">3.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">4.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">4.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">5.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">5.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br></pre></td></tr></table></figure>

<p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：</p>
<ul>
<li>首先调用c.next()启动生成器；</li>
<li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</li>
<li>consumer通过yield拿到消息，处理，又通过yield把结果传回；</li>
<li>produce拿到consumer处理的结果，继续生产下一条消息；</li>
<li>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</li>
</ul>
<p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p>
</details>

<p>参考链接：<a href="https://www.jianshu.com/p/73b070eebf50" target="_blank" rel="noopener">async/await的基础用法</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Johninch</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://johninch.github.io/2019/10/30/asyncAwait/">https://johninch.github.io/2019/10/30/asyncAwait/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://johninch.github.io">JohninchのBlog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ES6/">ES6</a><a class="post-meta__tags" href="/tags/异步/">异步</a></div><div class="social-share" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/11/13/variablesAndTypes1/"><i class="fa fa-chevron-left">  </i><span>JS专题-变量与类型-（1）JS数据类型</span></a></div><div class="next-post pull-right"><a href="/2019/10/29/eleMessage/"><span>ElementUI Message 二次封装</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '96a2af06b5748b4ede1e',
  clientSecret: '4e684cb9e506bdd7f5732db53d3f99da0315afbb',
  repo: 'johninch.github.io',
  owner: 'johninch',
  admin: 'johninch',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Johninch</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.3"></script><script src="/js/fancybox.js?version=1.6.3"></script><script src="/js/sidebar.js?version=1.6.3"></script><script src="/js/copy.js?version=1.6.3"></script><script src="/js/fireworks.js?version=1.6.3"></script><script src="/js/transition.js?version=1.6.3"></script><script src="/js/scroll.js?version=1.6.3"></script><script src="/js/head.js?version=1.6.3"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.7,"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body></html>