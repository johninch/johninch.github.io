<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="linkedList"><meta name="keywords" content="算法,数据结构,链表,leetcode"><meta name="author" content="Johninch"><meta name="copyright" content="Johninch"><title>linkedList | JohninchのBlog</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.3"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"0XJEPPY0XU","apiKey":"e06877afb5799837e43083eaa72dae92","indexName":"inch-blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#从尾到头打印链表"><span class="toc-number">1.</span> <span class="toc-text">从尾到头打印链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、题目描述"><span class="toc-number">1.1.</span> <span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、思路"><span class="toc-number">1.2.</span> <span class="toc-text">2、思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、代码实现"><span class="toc-number">1.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除链表中重复的结点"><span class="toc-number">2.</span> <span class="toc-text">删除链表中重复的结点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、题目描述-1"><span class="toc-number">2.1.</span> <span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、思路-1"><span class="toc-number">2.2.</span> <span class="toc-text">2、思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、代码实现-1"><span class="toc-number">2.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#合并两个有序链表"><span class="toc-number">3.</span> <span class="toc-text">合并两个有序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、题目描述-2"><span class="toc-number">3.1.</span> <span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、思路-2"><span class="toc-number">3.2.</span> <span class="toc-text">2、思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、代码实现-2"><span class="toc-number">3.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反转链表"><span class="toc-number">4.</span> <span class="toc-text">反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、题目描述-3"><span class="toc-number">4.1.</span> <span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、思路-3"><span class="toc-number">4.2.</span> <span class="toc-text">2、思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、代码实现-3"><span class="toc-number">4.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表中倒数第k个结点"><span class="toc-number">5.</span> <span class="toc-text">链表中倒数第k个结点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、题目描述-4"><span class="toc-number">5.1.</span> <span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、思路-4"><span class="toc-number">5.2.</span> <span class="toc-text">2、思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、代码实现-4"><span class="toc-number">5.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个链表的第一个公共结点"><span class="toc-number">6.</span> <span class="toc-text">两个链表的第一个公共结点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、题目描述-5"><span class="toc-number">6.1.</span> <span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、思路-5"><span class="toc-number">6.2.</span> <span class="toc-text">2、思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、代码实现-5"><span class="toc-number">6.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表中环的入口结点"><span class="toc-number">7.</span> <span class="toc-text">链表中环的入口结点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、题目描述-6"><span class="toc-number">7.1.</span> <span class="toc-text">1、题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、思路-6"><span class="toc-number">7.2.</span> <span class="toc-text">2、思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、代码实现-6"><span class="toc-number">7.3.</span> <span class="toc-text">3、代码实现</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/16729420?s=460&amp;v=4"></div><div class="author-info__name text-center">Johninch</div><div class="author-info__description text-center">张宇驰的博客主页</div><div class="follow-button"><a href="https://github.com/johninch">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">23</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://https://johninch.github.io/Roundtable/">Roundtable-io</a><a class="author-info-links__name text-center" href="https://github.com/johninch/Roundtable">Roundtable-repo</a><a class="author-info-links__name text-center" href="https://github.com/esop-fed">ESOP-FED</a><a class="author-info-links__name text-center" href="https://dannisi.github.io/">Caleb</a><a class="author-info-links__name text-center" href="https://niannings.github.io/">niannings</a><a class="author-info-links__name text-center" href="https://Xmtd.github.io/">Xmtd</a><a class="author-info-links__name text-center" href="https://febcat.github.io/">febcat</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">JohninchのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">linkedList</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-17</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/javascript/">javascript</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 16 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>链表练习题集合：1、从尾到头打印链表；2、删除链表中重复的结点；3、合并两个有序链表；4、反转链表；5、链表中倒数第k个结点；6、两个链表的第一个公共结点；7、链表中环的入口结点；8、复杂链表的复制；</p>
</blockquote>
<a id="more"></a>


<p>构建基础链表及功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value, next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.next = next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find(index) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index; ++i) &#123;</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insert(value, index) &#123;</span><br><span class="line">    <span class="keyword">const</span> prev = <span class="keyword">this</span>.find(index)</span><br><span class="line">    <span class="keyword">const</span> next = <span class="keyword">new</span> Node(value, prev.next)</span><br><span class="line">    prev.next = next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><h4 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h4><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<h4 id="2、思路"><a href="#2、思路" class="headerlink" title="2、思路"></a>2、思路</h4><p>(三种方法：借助栈、递归、列表的首位插入)</p>
<p>从头到尾打印链表比较简单，从尾到头很自然的可以想到先将链表进行反转，然后再打印。但是，通常我们不希望改变原链表的结构，这是一个<strong>只读操作</strong>。</p>
<p>进一步分析，这是一个典型的“后入先出”的思想，因此很自然的可以想到用<strong>栈来实现</strong>，每遍历一个结点，可以将其压入栈中，遍历结束后再逐个弹栈，将结点值存入ArrayList，这样就实现了从尾到头的打印。</p>
<p>更进一步，既然想到了用栈，那一定可以通过<strong>递归来实现</strong>。每访问到一个结点，先递归输出其后的结点，再输出该结点自身即可。</p>
<p>另外，当我们使用Java或者python语言时，有一种比较巧妙的方法就是使用列表的插入方法，每次插入数据，都总是<strong>插入到首位</strong>，这样得到的List就是从尾到头的链表序列。</p>
<h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> List()</span><br><span class="line">list.insert(<span class="string">'a'</span>, <span class="number">0</span>)</span><br><span class="line">list.insert(<span class="string">'b'</span>, <span class="number">1</span>)</span><br><span class="line">list.insert(<span class="string">'c'</span>, <span class="number">2</span>)</span><br><span class="line">list.insert(<span class="string">'d'</span>, <span class="number">3</span>)</span><br><span class="line">list.insert(<span class="string">'e'</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归法：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFromTailToHead</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  node.next &amp;&amp; printFromTailToHead(node.next)</span><br><span class="line">  node.value &amp;&amp; <span class="built_in">console</span>.log(node.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = printFromTailToHead(list.head)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<h3 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h3><h4 id="1、题目描述-1"><a href="#1、题目描述-1" class="headerlink" title="1、题目描述"></a>1、题目描述</h4><p>删除<strong>有序链表</strong>中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p>
<h4 id="2、思路-1"><a href="#2、思路-1" class="headerlink" title="2、思路"></a>2、思路</h4><p>删除重复结点，也就是如果当前结点和下一个结点的值相同，那么就是重复的结点，都可以被删除，为了保证删除之后的链表的连通性，在删除之后，要把当前结点前面的结点和下一个没有重复的结点链接起来，为此，程序需要记录当前的最后一个不重复结点，即程序中的pre。重点在于：一定要确保当前链接到链表中的一定是不会再重复的结点，具体见代码实现。</p>
<p>关于第一个结点如果重复怎么办的问题，我们不用单独考虑，可以使用链表中一贯的做法，加一个头结点即可。</p>
<h4 id="3、代码实现-1"><a href="#3、代码实现-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 注意这里的前提是 有序链表、不保留重复节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteDuplication</span>(<span class="params">pHead</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pHead === <span class="literal">null</span> || pHead.next === <span class="literal">null</span>) &#123; <span class="comment">// 只有0个或1个节点，则返回</span></span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> dummy = <span class="keyword">new</span> Node(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  dummy.next = pHead; <span class="comment">// 创建一个虚拟节点，让其位于头节点之前，以处理第一个节点重复的问题</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> pre = dummy;</span><br><span class="line">  <span class="keyword">var</span> cur = pHead;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur !== <span class="literal">null</span> &amp;&amp; cur.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.next.val === cur.val) &#123; <span class="comment">// 当前节点是重复节点</span></span><br><span class="line">      <span class="keyword">var</span> curRepetitiveVal = cur.val;</span><br><span class="line">      <span class="keyword">while</span> (cur !== <span class="literal">null</span> &amp;&amp; cur.val === curRepetitiveVal) &#123;</span><br><span class="line">        <span class="comment">// 跳过值与当前节点相同的全部节点,找到第一个与当前节点不同的节点</span></span><br><span class="line">        cur = cur.next;</span><br><span class="line">      &#125;</span><br><span class="line">      pre.next = cur; <span class="comment">// 跳过重复节点，前后连接</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前节点不重复，整体前移</span></span><br><span class="line">      pre = cur;</span><br><span class="line">      cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里的前提是 有序链表、保留重复节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteDuplication</span>(<span class="params">pHead</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pHead === <span class="literal">null</span> || pHead.next === <span class="literal">null</span>) &#123; <span class="comment">// 链表为空或只有 1个节点，则返回</span></span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> dummy = <span class="keyword">new</span> Node(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  dummy.next = pHead; <span class="comment">// 创建一个虚拟节点，让其位于头节点之前，以处理第一个节点重复的问题</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> pre = dummy;</span><br><span class="line">  <span class="keyword">var</span> cur = pHead;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur !== <span class="literal">null</span> &amp;&amp; cur.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.next.val === cur.val) &#123; <span class="comment">// 当前节点是重复节点</span></span><br><span class="line">      pre = cur <span class="comment">// 保留重复节点，在发现重复时，pre指针立刻指向重复节点的第一个</span></span><br><span class="line">      <span class="keyword">var</span> curRepetitiveVal = cur.val;</span><br><span class="line">      <span class="keyword">while</span> (cur !== <span class="literal">null</span> &amp;&amp; cur.val === curRepetitiveVal) &#123;</span><br><span class="line">        <span class="comment">// 跳过值与当前节点相同的全部节点,找到第一个与当前节点不同的节点</span></span><br><span class="line">        cur = cur.next;</span><br><span class="line">      &#125;</span><br><span class="line">      pre.next = cur; <span class="comment">// 跳过重复节点，前后连接</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前节点不重复，整体前移</span></span><br><span class="line">      pre = cur;</span><br><span class="line">      cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><h4 id="1、题目描述-2"><a href="#1、题目描述-2" class="headerlink" title="1、题目描述"></a>1、题目描述</h4><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>
<h4 id="2、思路-2"><a href="#2、思路-2" class="headerlink" title="2、思路"></a>2、思路</h4><p>准备一个指针node，假设指向两个链表中节点的指针分别是：p1和p2。</p>
<p>比较p1和p2的value大小<br>如果，p1.value 小于 p2.value, node.next 指向 p1, p1 向后移动<br>否则，node.next 指向 p2, p2 向后移动<br>重复第 1 步，直到其中一个链表遍历完<br>跳出循环，将 node.next 指向未遍历完的链表的剩余部分<br>整个过程的时间复杂度是 O(N), 空间复杂度是 O(1)</p>
<h4 id="3、代码实现-2"><a href="#3、代码实现-2" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p1) &#123;</span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p2) &#123;</span><br><span class="line">    <span class="keyword">return</span> p1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> head = <span class="keyword">new</span> Node() <span class="comment">// 增加头节点</span></span><br><span class="line">  <span class="keyword">let</span> node = head</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p1 &amp;&amp; p2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.value &lt; p2.value) &#123;</span><br><span class="line">      node.next = p1</span><br><span class="line">      p1 = p1.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.next = p2</span><br><span class="line">      p2 = p2.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = node.next</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    node.next = p1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">    node.next = p2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p1) &#123;</span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p2) &#123;</span><br><span class="line">    <span class="keyword">return</span> p1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span> <span class="comment">// 头节点</span></span><br><span class="line">  <span class="keyword">if</span> (p1.value &lt; p2.value) &#123;</span><br><span class="line">    head = p1</span><br><span class="line">    head.next = merge(p1.next, p2)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    head = p2</span><br><span class="line">    head.next = merge(p1, p2.next)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h4 id="1、题目描述-3"><a href="#1、题目描述-3" class="headerlink" title="1、题目描述"></a>1、题目描述</h4><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h4 id="2、思路-3"><a href="#2、思路-3" class="headerlink" title="2、思路"></a>2、思路</h4><p>有两种方法可以实现：（1）链表头插法。从第二个节点开始依次插入到第一个节点之后，最后将第一个节点挪到新表结尾；（2）三指针。使用三个指针，分别指向当前遍历到的结点、它的前一个结点以及后一个结点。将指针反转后，三个结点依次前移即可；（3）递归方法。同样可以采用递归来实现反转。将头结点之后的链表反转后，再将头结点接到尾部即可。</p>
<img src="/images/linkedList/reverseLinkList1.jpeg" alt="链表头插法" style="width:400px;">

<img src="/images/linkedList/reverseLinkList2.png" alt="三指针法" style="width:400px;">


<h4 id="3、代码实现-3"><a href="#3、代码实现-3" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://blog.csdn.net/feliciafay/article/details/6841115</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ”链表头插法“：从第2个节点到第N个节点，依次逐节点插入到第1个节点(head节点)之后，最后将第一个节点挪到新表的表尾。</span></span><br><span class="line"><span class="comment">// 时间复杂度是 O(N)，空间复杂度也是 O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) &#123;    <span class="comment">// 链表为空或只有一个节点时，不用反转</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> p = head.next <span class="comment">// 从第二个节点操作</span></span><br><span class="line">  <span class="keyword">let</span> q</span><br><span class="line">  <span class="keyword">while</span> (p.next) &#123;</span><br><span class="line">    q = p.next</span><br><span class="line"></span><br><span class="line">    p.next = q.next</span><br><span class="line">    q.next = head.next</span><br><span class="line">    head.next = q</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p.next = head <span class="comment">// 成环</span></span><br><span class="line">  head = p.next.next <span class="comment">// 新head变为原head的next</span></span><br><span class="line">  p.next.next = <span class="literal">null</span> <span class="comment">// 断掉环</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ”三指针法“：使用p、q 两个节点间的指向反向，同时用 临时指针r 来记录剩下的链表</span></span><br><span class="line"><span class="comment">// 链表原地操作，时间复杂度是 O(N)，但是空间复杂度只有 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) &#123;    <span class="comment">// 链表为空或只有一个节点时，不用反转</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> p = head</span><br><span class="line">  <span class="keyword">let</span> q = head.next;</span><br><span class="line">  head.next = <span class="literal">null</span>;    <span class="comment">// 让原本的head变为尾节点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> r;    <span class="comment">// 临时指针</span></span><br><span class="line">  <span class="keyword">while</span> (q) &#123; <span class="comment">// 当q为null时，反转完毕</span></span><br><span class="line">    r = q.next; <span class="comment">// 保留下一个step要处理的指针</span></span><br><span class="line">    q.next = p; <span class="comment">// 这一步使p、q的指向反向</span></span><br><span class="line"></span><br><span class="line">    p = q; <span class="comment">// p、q后移</span></span><br><span class="line">    q = r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p; <span class="comment">// 此时 p 就是反转后链表的 头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ”递归“：对于树的大部分问题，基本可以考虑用递归来解决。但是我们不太熟悉的一点是，对于单链表的一些问题，也可以使用递归。</span></span><br><span class="line"><span class="comment">// 可以认为单链表是一颗永远只有左(右)子树的树，因此可以考虑用递归来解决:</span></span><br><span class="line"><span class="comment">// 现在需要把A-&gt;B-&gt;C-&gt;D进行反转，</span></span><br><span class="line"><span class="comment">// 可以先假设B-&gt;C-&gt;D已经反转好，已经成为了D-&gt;C-&gt;B,那么接下来要做的事情就是将D-&gt;C-&gt;B看成一个整体，让这个整体的next指向A，所以问题转化了反转B-&gt;C-&gt;D。那么，</span></span><br><span class="line"><span class="comment">// 可以先假设C-&gt;D已经反转好，已经成为了D-&gt;C,那么接下来要做的事情就是将D-&gt;C看成一个整体，让这个整体的next指向B，所以问题转化了反转C-&gt;D。那么，</span></span><br><span class="line"><span class="comment">// 可以先假设D(其实是D-&gt;NULL)已经反转好，已经成为了D(其实是head-&gt;D),那么接下来要做的事情就是将D(其实是head-&gt;D)看成一个整体，让这个整体的next指向C，所以问题转化了反转D。</span></span><br><span class="line"><span class="comment">// 上面这个过程就是递归的过程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log('递归前')</span></span><br><span class="line">  <span class="keyword">var</span> new_head = reverseList(head.next);  <span class="comment">// 反转后的头节点</span></span><br><span class="line">  <span class="comment">// var temp = new_head</span></span><br><span class="line">  <span class="comment">// console.log('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;', JSON.stringify(temp))</span></span><br><span class="line">  <span class="comment">// console.log('++++++++', JSON.stringify(head.next.next), JSON.stringify(head)) // JSON.stringify(head.next.next)为null</span></span><br><span class="line">  <span class="comment">// console.log('递归后')</span></span><br><span class="line"></span><br><span class="line">  head.next.next = head; <span class="comment">// 将反转后的链表的尾节点与当前节点相连</span></span><br><span class="line">  head.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h3><h4 id="1、题目描述-4"><a href="#1、题目描述-4" class="headerlink" title="1、题目描述"></a>1、题目描述</h4><p>输入一个链表，输出该链表中倒数第k个结点。为了符合习惯，从1开始计数，即链表的尾结点是倒数第1个节点。例如，一个链表有6个结点，从头结点开始，它们的值依次是1,2,3,4,5,6。则这个链表倒数第三个结点是值为4的结点。</p>
<h4 id="2、思路-4"><a href="#2、思路-4" class="headerlink" title="2、思路"></a>2、思路</h4><p>对于单链表来说，没有从后向前的指针，因此一个直观的解法是先进行一次遍历，统计出链表中结点的个数n，第二次再进行一次遍历，找到第n-k+1个结点就是我们要找的结点，但是这需要对链表进行两次遍历。</p>
<p>为了实现一次遍历，我们这里采用<strong>双指针解法（快慢指针）</strong>。我们可以定义两个指针，第一个指针从链表的头指针开始先向前走k步，第二个指针保持不动，从第k+1步开始，第二个指针也从头开始前进，两个指针都每次前进一步。这样，两个指针的距离都一直保持在k，当快指针（走在前面的）到达null时，慢指针（走在后面的）正好到达第k个结点。注意：要时刻留意空指针的判断。</p>
<h4 id="3、代码实现-4"><a href="#3、代码实现-4" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：遍历两遍，第一遍得出链表长度n，第二遍遍历到第n-k+1个节点即为所求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：快慢指针</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findKthFromTail</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> fast = head,</span><br><span class="line">    slow = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">    <span class="keyword">if</span> (!fast) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码, 分别输出倒数第2、3和5个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> node3 = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="literal">null</span>),</span><br><span class="line">  node2 = <span class="keyword">new</span> Node(<span class="number">2</span>, node3),</span><br><span class="line">  node1 = <span class="keyword">new</span> Node(<span class="number">1</span>, node2),</span><br><span class="line">  head = <span class="keyword">new</span> Node(<span class="number">0</span>, node1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findKthFromTail(head, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(findKthFromTail(head, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(findKthFromTail(head, <span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<h3 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h3><h4 id="1、题目描述-5"><a href="#1、题目描述-5" class="headerlink" title="1、题目描述"></a>1、题目描述</h4><p>输入两个链表，找出它们的第一个公共结点。</p>
<h4 id="2、思路-5"><a href="#2、思路-5" class="headerlink" title="2、思路"></a>2、思路</h4><p>方法一：<strong>借助辅助栈</strong>。我们可以把两个链表的结点依次压入到两个辅助栈中，这样两个链表的尾结点就位于两个栈的栈顶，接下来比较两个栈顶的结点是否相同。如果相同，则把栈顶弹出继续比较下一个，直到找到最后一个相同的结点。此方法也很直观，时间复杂度为O(m+n)，但使用了O(m+n)的空间，相当于用空间换取了时间效率的提升。</p>
<p>方法二：<strong>快慢指针（将两个链表设置成一样长）</strong>。具体做法是先求出两个链表各自的长度，然后将长的链表的头砍掉，也就是长的链表先走几步，使得剩余的长度与短链表一样长，这样同时向前遍历便可以得到公共结点。时间复杂度为O(m+n)，不需要额外空间。</p>
<h4 id="3、代码实现-5"><a href="#3、代码实现-5" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：栈实现 时间为O(m+n)，空间为O(m+n)</span></span><br><span class="line"><span class="comment">// 在第一个公共节点前的节点都是不相同的，因此只要倒序遍历两个链表，找出最后一个出现的相同节点即可。</span></span><br><span class="line"><span class="comment">// 因为链表不能倒序遍历，所以借助栈实现。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findCommon</span>(<span class="params">list1, list2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack1 = [],</span><br><span class="line">    stack2 = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> node = list1;</span><br><span class="line">  <span class="keyword">while</span> (node) &#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  node = list2;</span><br><span class="line">  <span class="keyword">while</span> (node) &#123;</span><br><span class="line">    stack2.push(node);</span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  node = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (stack1.length &amp;&amp; stack2.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> top1 = stack1.pop(),</span><br><span class="line">      top2 = stack2.pop();</span><br><span class="line">    <span class="keyword">if</span> (top1 === top2) &#123;</span><br><span class="line">      node = top1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：快慢指针 时间为O(m+n)，不需要额外空间</span></span><br><span class="line"><span class="comment">// 假设链表 A 长度大于链表 B 长度，它们的长度差为 diff。</span></span><br><span class="line"><span class="comment">// 让 A 的指针先移动 diff 的位移，然后 A 和 B 的指针再同时向后移动，每次比较节点，选出第一个出现的相同节点。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findCommon</span>(<span class="params">list1, list2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length1 = <span class="number">0</span>,</span><br><span class="line">    length2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> node = list1;</span><br><span class="line">  <span class="keyword">while</span> (node) &#123;</span><br><span class="line">    ++length1;</span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  node = list2;</span><br><span class="line">  <span class="keyword">while</span> (node) &#123;</span><br><span class="line">    ++length2;</span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> diff = <span class="built_in">Math</span>.abs(length1 - length2),</span><br><span class="line">    longList = <span class="literal">null</span>,</span><br><span class="line">    shortList = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (length1 &gt; length2) &#123;</span><br><span class="line">    longList = list1;</span><br><span class="line">    shortList = list2;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    longList = list2;</span><br><span class="line">    shortList = list1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    longList = longList.next;</span><br><span class="line">    --diff;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (longList &amp;&amp; shortList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (longList === shortList) &#123;</span><br><span class="line">      <span class="keyword">return</span> longList;</span><br><span class="line">    &#125;</span><br><span class="line">    longList = longList.next;</span><br><span class="line">    shortList = shortList.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> node4th = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> node3th = <span class="keyword">new</span> Node(<span class="number">3</span>, node4th);</span><br><span class="line"><span class="keyword">const</span> list1 = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="keyword">new</span> Node(<span class="number">3</span>, node3th)));</span><br><span class="line"><span class="keyword">const</span> list2 = <span class="keyword">new</span> Node(<span class="number">5</span>, <span class="keyword">new</span> Node(<span class="number">6</span>, node3th));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findCommon(list1, list2));</span><br></pre></td></tr></table></figure>

<h3 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h3><h4 id="1、题目描述-6"><a href="#1、题目描述-6" class="headerlink" title="1、题目描述"></a>1、题目描述</h4><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<h4 id="2、思路-6"><a href="#2、思路-6" class="headerlink" title="2、思路"></a>2、思路</h4><p>第一步：确定一个链表是否有环。这一步就是快慢指针法，定义两个指针，同时从链表的头结点出发，快指针一次走两步，慢指针一次走一步。如若有环，两个指针必定相遇，也就是如果快指针反追上了慢指针，说明存在环（这里要注意，两指针相遇的地方一定在环中，但不一定是环的入口），如果快指针走到了链表的末尾（指向了NULL），则说明不存在环。</p>
<p>第二步：找到环的入口点。这还是可以利用双指针来解决，两个指针初始都指向头结点，如果我们可以知道环中的结点个数，假设为n，那么第一个指针先向前走n步，然后两个指针（另一个从头结点开始）同时向前，当两个指针再次相遇时，他们的相遇点正好就是环的入口点。</p>
<h4 id="3、代码实现-6"><a href="#3、代码实现-6" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 环形链表的入口节点</span></span><br><span class="line"><span class="comment">// 方法：分两步</span></span><br><span class="line"><span class="comment">// 阶段一 快慢指针判断是否成环，相遇必定成环，快指针走到链尾指向null则无环；</span></span><br><span class="line"><span class="comment">// 阶段二 如果成环，记录第一次相遇的节点firstMeet，使用两个慢指针(即步频为1的)一个从head，一个从firstMeet出发，相遇时从head出发的指针则为入环点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectCycle</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阶段1：快慢指针，速度fast步频2，slow步频1，试图找出第一次相遇的点，判断是否成环</span></span><br><span class="line">  <span class="keyword">let</span> fast = head, slow = head, firstMeet = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">while</span>(slow &amp;&amp; fast &amp;&amp; fast.next) &#123;</span><br><span class="line">      slow = slow.next</span><br><span class="line">      fast = fast.next.next</span><br><span class="line">      <span class="keyword">if</span>(slow === fast) &#123;</span><br><span class="line">          <span class="comment">// 相遇时，慢指针走的路程就是 相遇点firstMeet</span></span><br><span class="line">          firstMeet = slow</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!firstMeet) &#123;</span><br><span class="line">      <span class="comment">// 没有相遇，不成环</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阶段2：用 阶段1中找到的 相遇点firstMeet 来找到环的入口</span></span><br><span class="line">  <span class="comment">// 设定head到入环点为n，假设环路大于n，环内路被分为b与n。</span></span><br><span class="line">  <span class="comment">// 慢指针从入环处开始跑b步，距离入环处就剩下了n。</span></span><br><span class="line">  <span class="comment">// 此时，快指针则是从距离入环处n步远的位置开始跑了2b步，距离入环处也是剩下了n。</span></span><br><span class="line">  <span class="comment">// 由于距离入环处都是n，所以他们相遇了，这个点就是firstMeet</span></span><br><span class="line">  <span class="comment">// 所以最后，使用两个slow指针，一个从head出发，一个从firstMeet出发，都走n步，相遇，返回从head出发的slow即可</span></span><br><span class="line">  <span class="comment">// 另外，对于环路小于n的情况，则可将多个小环展开视为一个大环，情况是一样的</span></span><br><span class="line">  <span class="keyword">while</span>(firstMeet &amp;&amp; head) &#123;</span><br><span class="line">      <span class="keyword">if</span>(firstMeet === head) &#123;</span><br><span class="line">          <span class="keyword">return</span> head</span><br><span class="line">      &#125;</span><br><span class="line">      firstMeet = firstMeet.next</span><br><span class="line">      head = head.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Johninch</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://johninch.github.io/2019/12/18/linkedList/">https://johninch.github.io/2019/12/18/linkedList/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://johninch.github.io">JohninchのBlog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/算法/">算法</a><a class="post-meta__tags" href="/tags/数据结构/">数据结构</a><a class="post-meta__tags" href="/tags/链表/">链表</a><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a></div><div class="social-share" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/2019/12/12/eslintPrettier/"><span>eslint+husky+prettier+lint-staged</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '96a2af06b5748b4ede1e',
  clientSecret: '4e684cb9e506bdd7f5732db53d3f99da0315afbb',
  repo: 'johninch.github.io',
  owner: 'johninch',
  admin: 'johninch',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 By Johninch</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.3"></script><script src="/js/fancybox.js?version=1.6.3"></script><script src="/js/sidebar.js?version=1.6.3"></script><script src="/js/copy.js?version=1.6.3"></script><script src="/js/fireworks.js?version=1.6.3"></script><script src="/js/transition.js?version=1.6.3"></script><script src="/js/scroll.js?version=1.6.3"></script><script src="/js/head.js?version=1.6.3"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.7,"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body></html>